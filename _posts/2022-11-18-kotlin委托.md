---
layout: post
title: kotlin 委托
date: 2022-11-18
Author: aixz
categories:
tags: [笔记, kotlin]
comments: true
---

### 委托
主流语言都有委托模式.有些语言只能单父类继承,拓展性不强,不够灵活,使用委托替代,能够更灵活的控制实现的粒度.

kotlin 通过关键字 by 委托给具体实现

```kotlin
interface Base {
  val message: String
	fun print()
}
class BaseImpl(val x: Int) : Base {
  override val message = "BaseImpl: x = $x"
	override fun print() { print(x) }
}
class Derived(b: Base) : Base by b
fun main() {
	val b = BaseImpl(10)
	Derived(b).print()
}
```

由委托实现的接口成员可以被覆盖,下例输出为'abc'.

```kotlin
class Derived(b: Base) : Base by b{
  override fun print() { print("abc") }
}
fun main() {
	val b = BaseImpl(10)
	Derived(b).print()
}
```

但是如果涉及到成员的重写,则不会被委托对象的成员调用:

```kotlin
class BaseImpl(val x: Int) : Base {
  override val message = "BaseImpl: x = $x"
	override fun print() { print(message) }
}
class Derived(b: Base) : Base by b{
  override val message = "Derived message"
}
fun main() {
	val b = BaseImpl(10)
	Derived(b).print()
}
//out:BaseImpl: x = 10
```

### 属性委托

语法: val/var <属性名>:类型 by <表达式>.属性对应的get()和set()方法会委托给表达式的```getValue```和```getValue```方法.

```kotlin
class Delegate {
    var delegateValue:String = "123"
    operator fun getValue(thisRef:Any?,property:KProperty<*>):String{
        return "$thisRef, thank you for delegating '${property.name}' to me! and value is $delegateValue"
    }
    operator fun setValue(thisRef: Any?,property: KProperty<*>,value: String){
        println("$value has been assigned to '${property.name}' in $thisRef.")
        delegateValue = value
    }
}
class Derived(){
    var p:String by Delegate()
}
fun main() {
    val driverd = Derived()
    println(driverd.p)
    driverd.p = "abc"
    println(driverd.p)
}
//out:
//Derived@77459877, thank you for delegating 'p' to me! and value is 123
//abc has been assigned to 'p' in @77459877.
//@77459877, thank you for delegating 'p' to me! and value is abc
```

当从委托到一个```Delegate```实例的```p```读取时,将调用```Delegate```的```getValue()```函数,它的第一个参数是读出```p```的对象,第二个参数保存了对```p```自身的描述.

### 延迟属性 Lazy properties

```lazy()```是接受一个**lambda**并返回一个```lazy<T>```实例的函数,返回的实例可以作为实现延迟属性的委托.第一次调用```get()```会执行已传递给```lazy()```的**lambda**表达式并记录结果.后续调用只是返回记录的结果.默认为线程安全的实现.

```kotlin
class Derived(){
    val lazyValue:String by lazy {
        println("computed!")
        "hello"
    }
}

//source code
public actual fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)
internal object UNINITIALIZED_VALUE
private class SynchronizedLazyImpl<out T>(initializer: () -> T, lock: Any? = null) : Lazy<T>, Serializable {
    private var initializer: (() -> T)? = initializer
    @Volatile private var _value: Any? = UNINITIALIZED_VALUE
    // final field is required to enable safe publication of constructed instance
    private val lock = lock ?: this
    override val value: T
        get() {
            val _v1 = _value
            if (_v1 !== UNINITIALIZED_VALUE) {
                @Suppress("UNCHECKED_CAST")
                return _v1 as T
            }
            return synchronized(lock) {
                val _v2 = _value
                if (_v2 !== UNINITIALIZED_VALUE) {
                    @Suppress("UNCHECKED_CAST") (_v2 as T)
                } else {
                    val typedValue = initializer!!()
                    _value = typedValue
                    initializer = null
                    typedValue
                }
            }
        }

    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE
    override fun toString(): String = if (isInitialized()) value.toString() else "Lazy value not initialized yet."
    private fun writeReplace(): Any = InitializedLazyImpl(value)
}

```

可以看到```_value```被声明为```@Volatil``保证了可见性,关于属性的volatile说明,java内存模型中线程会存储本地内存副本(local memory),它会缓存JVM共享变量.声明为volatile的属性在写时会插入内存屏障 StoreStore| code |StoreLoad,这可以防止指令重排,并且当其它线程读取该变量时会先同步共享变量到本地内存,即当一个线程修改属性值后其它线程读取时都能立刻读取到修改后的值,该属性的修改对于多个线程是**可见的**.

